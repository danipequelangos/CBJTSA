)
ggplot(times, aes(x=ProcessG, y=Time, color=ProcessG))+
geom_boxplot()+
theme(panel.grid.major=element_line(color="skyblue", size=0.5))
times<-read.table("C:/Users/Daniel/Desktop/Trasgo/(A)Times.txt", sep = ";",dec = ".",header = T)
iniShape<-read.table("C:/Users/Daniel/Desktop/Trasgo/(A)IniShape.txt", sep = ";",dec = ".",header = T)
iniShape$Shape<-iniShape$To-iniShape$From
finShape<-read.table("C:/Users/Daniel/Desktop/Trasgo/(A)FinShape.txt", sep = ";",dec = ".",header = T)
finShape$Shape<-finShape$To-finShape$From
library(ggplot2)
palette(rainbow(50))
graph<-ggplot(times, aes(x=Iter, y=Time, group=Process)) +
geom_line(aes(color=Process)) +
scale_color_gradientn(colours = rainbow(50))
graph
times$ProcessG<-as.factor(times$Process)
ggplot(times, aes(x=ProcessG, y=Time, color=ProcessG)) +
geom_boxplot() +
theme(panel.grid.major=element_line(color="skyblue", size=0.5))
times$IterG<-as.factor(times$Iter)
ggplot(times, aes(x=IterG, y=Time, color=IterG)) +
geom_boxplot() +
theme(panel.grid.major=element_line(color="skyblue", size=0.5))
times$ProcessG<-as.factor(times$Process)
ggplot(times, aes(x=ProcessG, y=Time, color=Iter)) +
geom_boxplot() +
theme(panel.grid.major=element_line(color="skyblue", size=0.5))
palette(rainbow(50))
ggplot(times, aes(x=Iter, y=Time, group=ProcessG)) +
geom_line(aes(color=ProcessG)) +
scale_color_gradientn(colours = rainbow(50))
ggplot(times, aes(x=Iter, y=Time, group=Process)) +
geom_line(aes(color=ProcessG)) +
scale_color_gradientn(colours = rainbow(50))
ggplot(times, aes(x=Iter, y=Time, group=ProcessG)) +
geom_line(aes(color=Process)) +
scale_color_gradientn(colours = rainbow(50))
ggplot(times, aes(x=Iter, y=Time, group=Process)) +
geom_line(aes(color=Process))
ggplot(times, aes(x=Iter, y=Time, group=Process)) +
geom_line(aes(color=Process))+
scale_colour_manual(values=rainbow(50))
ggplot(times, aes(x=Iter, y=Time, group=Process)) +
geom_line(aes(color=ProcessG))+
scale_colour_manual(values=rainbow(50))
ggplot(times, aes(x=Iter, y=Time, group=Process)) +
geom_line(aes(color=ProcessG))+
scale_colour_manual(values=rainbow(100))
ggplot(times, aes(x=Iter, y=Time, group=Process)) +
geom_line(aes(color=ProcessG))+
scale_colour_manual(values=rainbow(50))
colores<-rainbow(500)[seq(1,500,10)]
len(colores)
length(colores)
length(rainbow(50))
colores<-rainbow(500)[seq(1,500,10)]
ggplot(times, aes(x=Iter, y=Time, group=Process)) +
geom_line(aes(color=ProcessG))+
scale_colour_manual(values=colores)
palette(rainbow(50))
ggplot(times, aes(x=Iter, y=Time, group=Process)) +
geom_line(aes(color=ProcessG))+
scale_colour_manual(values=rainbow(50))
ggplot(times, aes(x=ProcessG, y=Time, color=ProcessG)) +
geom_boxplot() +
theme(panel.grid.major=element_line(color="skyblue", size=0.5))
install.packages("timeSeries")
knitr::opts_chunk$set(echo = TRUE)
library(anscombe)
ff <- y ~ x
mods <- setNames(as.list(1:4), paste0("lm", 1:4))
for(i in 1:4) {
ff[2:3] <- lapply(paste0(c("y","x"), i), as.name)
## or   ff[[2]] <- as.name(paste0("y", i))
##      ff[[3]] <- as.name(paste0("x", i))
mods[[i]] <- lmi <- lm(ff, data = anscombe)
print(anova(lmi))
}
op <- par(mfrow = c(2, 2), mar = 0.1+c(4,4,1,1), oma =  c(0, 0, 2, 0))
for(i in 1:4) {
ff[2:3] <- lapply(paste0(c("y","x"), i), as.name)
plot(ff, data = anscombe, col = "red", pch = 21, bg = "orange", cex = 1.2,
xlim = c(3, 19), ylim = c(3, 13))
abline(mods[[i]], col = "blue")
}
mtext("Anscombe's 4 Regression data sets", outer = TRUE, cex = 1.5)
par(op)
log2(4175)+1
log2(351)+1
log2(1000)+1
log2(748)+1
log2(8)+1
log2(34)+1
log2(20)+1
log2(4)+1
exp(0.1506-1.0212+1.5366)*3.38505
2-exp(0.1506-1.0212+1.5366)*3.38505
install.packages("ROCR")
library(ROCR)
install.packages("VGAM")
library(VGAM)
#Segunda parte (desorden mental)
datos<-read.table("F:/uni/MEA/Practica 6/mental.txt", header=T)
datos
colnames(datos)<-c("y","x2","x1")
datos
#1)
m1<-vglm(y~x1+x2, family=cumulative(parallel = T))
#1)
m1<-vglm(y~x1+x2, family=cumulative(parallel = T),data=datos)
summary(m1)
#2)
m2<-vglm(y~x1+x2+x1*x2, family=cumulative(parallel = T),data=datos)
summary(m2)
anova(m1,m2)
anova(, type="I")
anova(m1,m2, type="I")
knitr::opts_chunk$set(echo = TRUE)
datos <- read.table("F:/uni/MEA/Practica 7/cangrejos.txt", header=T)
y <- datos$satell
col <- datos$color
sp <- datos$spine
ancho <- datos$width
peso <- datos$weight
reg<-lm(y~ancho)
summary(reg)
anchog <- cut(ancho,breaks=c(min(ancho)-1,23.25,24.25,25.25,26.25,27.25,
28.25,29.25, max(ancho)),
labels=c("a1","a2","a3","a4","a5","a6","a7","a8"))
#medias de anchura del caparazo
medAnchura<-c()
for(i in c("a1","a2","a3","a4","a5","a6","a7","a8")){
medAnchura<-append(medAnchura,mean(ancho[which(anchog==i)]))
}
medAnchura
#numero medio de satelites
medSat<-c()
for(i in c("a1","a2","a3","a4","a5","a6","a7","a8")){
medSat<-append(medSat,mean(y[which(anchog==i)]))
}
medSat
#varianza del numero de satelites
varSat<-c()
for(i in c("a1","a2","a3","a4","a5","a6","a7","a8")){
varSat<-append(varSat,var(y[which(anchog==i)]))
}
varSat
#numero total de satelites
totSat<-c()
for(i in c("a1","a2","a3","a4","a5","a6","a7","a8")){
totSat<-append(totSat,sum(y[which(anchog==i)]))
}
totSat
#numero total de hembras
totHembras<-c()
for(i in c("a1","a2","a3","a4","a5","a6","a7","a8")){
totHembras<-append(totHembras,length(y[which(anchog==i)]))
}
totHembras
plot(medAnchura, medSat, col="red", pch="M", xaxt="n", ylim=c(0,max(varSat)))
points(medAnchura, varSat, col="blue", pch="V")
axis(1, at=medAnchura, labels=round(medAnchura))
greg<-glm(y~ancho, family=poisson(link=identity), start = c(reg$coefficients))
summary(greg)
greg2<-glm(y~ancho, family=poisson)
summary(greg2)
reg<-lm(y~ancho)
summary(reg)
AIC(reg)
greg$R
greg3<-glm(y~ancho, family="quasi"(link="log",variance="mu"))
summary(greg3)
library(MASS)
greg4<-glm.nb(y~ancho)
summary(greg4)
reg<-lm(y~ancho)
summary(reg)
Devianca(reg)
devianca(reg)
deviance(reg)
reg<-lm(y~ancho)
summary(reg)
knitr::opts_chunk$set(echo = TRUE)
datos<-read.table("F:/uni/MEA/Practica 7/accidentes.txt", header=T)
datos
cat("Tasa global de accidentes: ",mean(datos$accidentes/datos$anios),"\n")
TasaAntes<-mean(datos$accidentes[datos$antes0_despues1==0]/datos$anios[datos$antes0_despues1==0])
cat("Tasa de accidentes antes de las obras: ",mean(datos$accidentes[datos$antes0_despues1==0]/datos$anios[datos$antes0_despues1==0]),"\n")
TasaDespues<-mean(datos$accidentes[datos$antes0_despues1==0]/datos$anios[datos$antes0_despues1==1])
cat("Tasa de accidentes despues de las obras: ",mean(datos$accidentes[datos$antes0_despues1==1]/datos$anios[datos$antes0_despues1==1]),"\n")
cat("La razón entre las tasas es: ",TasaAntes/TasaDespues)
m0<-glm(datos$accidentes~datos$antes0_despues1, family=poisson(link=log), offset = log(datos$anios))
summary(m0)
cat("La razon de tasas es: ",exp(m0$coefficients[2]))
IC<-exp(m0$coefficients[2]+c(-1,1)*1.96*0.2734)
IC
m0<-glm(datos$accidentes~datos$antes0_despues1, family=poisson(link=log), offset = log(datos$anios))
summary(m0)
cat("La razon de tasas es: ",exp(m0$coefficients[2]))
IC<-exp(m0$coefficients[2]+c(-1,1)*1.96*0.2734)
IC
lugares<-as.factor(datos$lugar)
m1<-glm(datos$accidentes~datos$antes0_despues1+lugares, family = poisson(link=log), offset=log(datos$anios))
summary(m1)
knitr::opts_chunk$set(echo = TRUE)
datos <- read.table("resistividad.txt")
y <- datos$V1 ### respuesta
x1 <- 2*datos$V2-1 ### codificación -1, 1
x2 <- 2*datos$V3-1
x3 <- 2*datos$V4-1
x4 <- 2*datos$V5-1
resist<-cbind(y, x1, x2, x3, x4)
resist
mlm<-lm(y~x1+x2+x3+x4)
summary(mlm)
library(MASS)
bc<-boxcox(mlm)
cat("El lambda que hace máxima la función es: ",bc$x[bc$y==max(bc$y)])
mlm2<-lm(log(y)~x1+x2+x3+x4+x1*x2+x1*x3+x1*x4+x2*x3+x2*x4+x3*x4)
summary(mlm2)
stepAIC(mlm2)
anova(lm(log(y)~x1+x2+x3+x4+x1*x3+x2*x3+x3*x4),lm(log(y)~x1+x2+x3+x4+x2*x3+x3*x4),lm(log(y)~x1+x2+x3+x4+x3*x4),lm(log(y)~x1+x2+x3))
mlm3<-lm(log(y)~x1+x2+x3+x4+x1*x3+x2*x3+x3*x4)
summary(mlm3)
mlm4<-glm(log(y)~x1+x2+x3+x4+x1*x3+x2*x3+x3*x4)
summary(mlm4)
mg1<-glm(y~x1*x2+x1*x3+x1*x4+x2*x3+x2*x4+x3*x4, family = gamma(link=log))
mg1<-glm(y~x1*x2+x1*x3+x1*x4+x2*x3+x2*x4+x3*x4, family = gamma(link = "log"))
mg1<-glm(y~x1*x2+x1*x3+x1*x4+x2*x3+x2*x4+x3*x4, family = Gamma(link = "log"))
summary(mg1)
stepAIC(mg1)
select<-stepAIC(mg1)
select$model
summary(select)
mg2<-glm(formula = y ~ x1 + x2 + x3 + x4 + x1:x3 + x2:x3 + x3:x4,
family = Gamma(link = "log"))
select<-stepAIC(mg1)
summary(select)
mg2<-glm(formula = y ~ x1 + x2 + x3 + x4 + x1:x3 + x2:x3 + x3:x4,
family = Gamma(link = "log"))
gamma.dispersion(mg2)
gamma.shape(mg2)
gamma.dispersion(mg2)
gamma.shape(mg2)
#Basado en Pearson
summary(modelo)$dispersion
#Basado en Pearson
summary(mg2)$dispersion
#Basado en deviance
deviance(mg2)/mg2$df.residual
#Basado en el modelo
gamma.dispersion(mg2)
gamma.shape(mg2)
#Basado en Pearson
summary(mg2)$dispersion
#Basado en deviance
deviance(mg2)/mg2$df.residual
library(MASS)
AIC(mg2)
knitr::opts_chunk$set(echo = TRUE)
datos <- read.table("resistividad.txt")
y <- datos$V1 ### respuesta
x1 <- 2*datos$V2-1 ### codificación -1, 1
x2 <- 2*datos$V3-1
x3 <- 2*datos$V4-1
x4 <- 2*datos$V5-1
resist<-cbind(y, x1, x2, x3, x4)
resist
mlm<-lm(y~x1+x2+x3+x4)
summary(mlm)
library(MASS)
bc<-boxcox(mlm)
cat("El lambda que hace máxima la función es: ",bc$x[bc$y==max(bc$y)])
mlm2<-lm(log(y)~x1+x2+x3+x4+x1*x2+x1*x3+x1*x4+x2*x3+x2*x4+x3*x4)
summary(mlm2)
stepAIC(mlm2)
anova(lm(log(y)~x1+x2+x3+x4+x1*x3+x2*x3+x3*x4),lm(log(y)~x1+x2+x3+x4+x2*x3+x3*x4),lm(log(y)~x1+x2+x3+x4+x3*x4),lm(log(y)~x1+x2+x3))
mlm3<-lm(log(y)~x1+x2+x3+x4+x1*x3+x2*x3+x3*x4)
summary(mlm3)
mlm4<-glm(log(y)~x1+x2+x3+x4+x1*x3+x2*x3+x3*x4)
summary(mlm4)
mg1<-glm(y~x1*x2+x1*x3+x1*x4+x2*x3+x2*x4+x3*x4, family = Gamma(link = "log"))
summary(mg1)
select<-stepAIC(mg1)
summary(select)
mg2<-glm(formula = y ~ x1 + x2 + x3 + x4 + x1:x3 + x2:x3 + x3:x4,
family = Gamma(link = "log"))
#Basado en el modelo
gamma.dispersion(mg2)
gamma.shape(mg2)
#Basado en Pearson
summary(mg2)$dispersion
#Basado en deviance
deviance(mg2)/mg2$df.residual
AIC(mg2)
influence.measures(mg2)
ols_plot_resid_stud(mg2)
data <- scan("http://robjhyndman.com/tsdldata/data/nybirths.dat")
data
data <- scan("http://robjhyndman.com/tsdldata/data/fancy.dat")
data.ts <- ts(data, frequency=12, start=c(1987,1))
data.ts
data.ts <- ts(data, frequency=15, start=c(1987,1))
data.ts
data.ts <- ts(data, frequency=1, start=c(1987,1))
data.ts
data.ts <- ts(data, frequency=12, start=c(1987,1))
data.ts
data.ts <- ts(data, frequency=4, start=c(1987,1))
data.ts
data.ts <- ts(data, frequency=365, start=c(1987,1))
data.ts
data.ts <- ts(data, frequency=12, start=c(1987,1))
data.ts
plot(data.ts)
data.ts <- ts(data, frequency=12, start=c(1987,1))
plot(data.ts)
install.packages("TTR")
library(TTR)
plot(data.ts)
plot(data.ts, type="p")
plot(data.ts, add=T)
points(data.ts)
plot(data.ts)
points(data.ts)
points(data.ts, pch=16)
points(data.ts, pch=16,  col = "red")
data.ts
#ACF
acf(data.ts)
#ACF
plot(acf(data.ts))
spectrum(data.ts)
#Periodograma
spec <- spectrum(data.ts)
spec$freq
spec$spec
tabla<-cbind(spec$freq,spec$spec)
tabla
###DIFERENCIACIONES###
x<-c(3,2,1)
diff(x, lag = 1)
diff(x, lag = 0)
diff(x, lag = 1)
diff(x, lag = 1, differences = 1)
diff(x, lag = 1, differences = 2)
###DIFERENCIACIONES###
x<-c(3,2,1,3,2,1)
diff(x, lag = 3, differences = 1)
data <- scan("http://robjhyndman.com/tsdldata/data/fancy.dat")
data.ts <- ts(data, frequency=12, start=c(1987,1))
#(diferenciacion estacional) y differences es el superindice (diferenciacion regular)
data.ts
#(diferenciacion estacional) y differences es el superindice (diferenciacion regular)
diff(data.ts)
#PACF
plot(pacf(data.ts))
###ESTIMACION###
arima(data.ts, order=c(0,1,1),include.mean = T)
###ESTIMACION###
model<-arima(data.ts, order=c(0,1,1),include.mean = T)
model$var.coef
###ESTIMACION###
model<-arima(data.ts, order=c(0,0,1),include.mean = T)
model$var.coef
install.packages("forecast")
library(forecast)
model2<-Arima(data.ts, order=c(0,1,1), inclue.mean = T)
model2<-Arima(data.ts, order=c(0,1,1), include.mean = T)
model2
auto.arima(data.ts)
model
model2
###ESTIMACION###
model<-arima(data.ts, order=c(0,1,1))
model2<-Arima(data.ts, order=c(0,1,1))
model
model2
###VALIDACION###
model2$residuals
###VALIDACION###
plot(acf(model2$residuals))
plot(pacf(model2$residuals))
Box.test(model2$residuals, lag=1, type="Ljung")
###COMPARACION###
model2
#no tiene el SBC
shapiro.test(model2$residuals)
t.test(model2$residuals)
forecast(model2)
f<-forecast(model2)
autoplot(f)
f
install.packages("devtools")
install.packages("roxygen2")
library(devtools)
load_all("C:/Users/Daniel/Desktop/cosas/TFG/TFGest/EasyTimeSeries")
install.packages("parallel")
library(parallel, lib.loc = "C:/Program Files/R/R-4.1.3/library")
library(glmnet)
??cv.glmnet
setwd("C:/Users/Daniel/Desktop/cosas/TFG/TFGest/CBJTSA")
setwd("C:/Users/Daniel/Desktop/cosas/TFG/TFGest")
#Para instalar la librería a partir del archivo
install.packages("CBJTSA_1.0.tar.gz", repos = NULL, type = "source")
library(CBJTSA)
#Me invento los tiempos para mostrar como funciona dateSeq y hacer los plots bien
?dateSeq
?arimaSimComp
detach("package:CBJTSA", unload = TRUE)
remove.packages("CBJTSA")
#Para instalar la librería a partir del archivo
install.packages("CBJTSA_1.0.tar.gz", repos = NULL, type = "source")
library(CBJTSA)
#Me invento los tiempos para mostrar como funciona dateSeq y hacer los plots bien
?dateSeq
####Fase de Identificacion####
#Grafica de la serie
?tsplot
setwd("C:/Users/Daniel/Desktop/cosas/TFG/TFGest/CBJTSA")
roxygen2::roxygenise()
setwd("C:/Users/Daniel/Desktop/cosas/TFG/TFGest/CBJTSA")
library(CBJTSA)
#Preiodograma de la serie
?tsspec
detach("package:CBJTSA", unload = TRUE)
remove.packages("CBJTSA")
setwd("C:/Users/Daniel/Desktop/cosas/TFG/TFGest")
#Para instalar la librería a partir del archivo
install.packages("CBJTSA_1.0.tar.gz", repos = NULL, type = "source")
library(CBJTSA)
#Me invento los tiempos para mostrar como funciona dateSeq y hacer los plots bien
?dateSeq
####Fase de Identificacion####
#Grafica de la serie
?tsplot
library(CBJTSA)
setwd("C:/Users/Daniel/Desktop/cosas/TFG/TFGest/CBJTSA")
library(CBJTSA)
#Me invento los tiempos para mostrar como funciona dateSeq y hacer los plots bien
?dateSeq
devtools::load_all(".")
install.packages("devtools")
devtools::load_all(".")
?'/'
setwd("C:/Users/Daniel/Desktop/cosas/TFG/TFGest")
remove.packages("CBJTSA")
#Para instalar la librería a partir del archivo
install.packages("CBJTSA_1.0.tar.gz", repos = NULL, type = "source")
#Para instalar la librería a partir del archivo
install.packages("CBJTSA_1.0.tar.gz", repos = NULL, type = "source")
detach(CBJTSA)
#Para instalar la librería a partir del archivo
install.packages("CBJTSA_1.0.tar.gz", repos = NULL, type = "source")
setwd("C:/Users/Daniel/Desktop/cosas/TFG/TFGest")
#Para instalar la librería a partir del archivo
install.packages("CBJTSA_1.0.tar.gz", repos = NULL, type = "source")
library(CBJTSA)
#Me invento los tiempos para mostrar como funciona dateSeq y hacer los plots bien
?dateSeq
detach("package:CBJTSA", unload = TRUE)
remove.packages("CBJTSA")
#Para instalar la librería a partir del archivo
install.packages("CBJTSA_1.0.tar.gz", repos = NULL, type = "source")
library(CBJTSA)
#Me invento los tiempos para mostrar como funciona dateSeq y hacer los plots bien
?dateSeq
####Fase de Identificacion####
#Grafica de la serie
?tsplot
detach("package:CBJTSA", unload = TRUE)
library(CBJTSA)
setwd("C:/Users/Daniel/Desktop/cosas/TFG/TFGest/CBJTSA")
library(CBJTSA)
library(CBJTSA)
#Me invento los tiempos para mostrar como funciona dateSeq y hacer los plots bien
?dateSeq
####Fase de Identificacion####
#Grafica de la serie
?tsplot
detach("package:CBJTSA", unload = TRUE)
remove.packages("CBJTSA")
setwd("C:/Users/Daniel/Desktop/cosas/TFG/TFGest")
#Para instalar la librería a partir del archivo
install.packages("CBJTSA_1.0.zip", repos = NULL, type = "source")
library(CBJTSA)
#Me invento los tiempos para mostrar como funciona dateSeq y hacer los plots bien
?dateSeq
detach("package:CBJTSA", unload = TRUE)
remove.packages("CBJTSA")
setwd("C:/Users/Daniel/Desktop/cosas/TFG/TFGest/CBJTSA")
setwd("C:/Users/Daniel/Desktop/cosas/TFG/TFGest")
#Para instalar la librería a partir del archivo
install.packages("CBJTSA_1.0.tar.gz", repos = NULL, type = "source")
library(CBJTSA)
#Me invento los tiempos para mostrar como funciona dateSeq y hacer los plots bien
?dateSeq
detach("package:CBJTSA", unload = TRUE)
remove.packages("CBJTSA")
#Para instalar la librería a partir del archivo
install.packages("CBJTSA_1.0.zip", repos = NULL, type = "source")
library(CBJTSA)
#Me invento los tiempos para mostrar como funciona dateSeq y hacer los plots bien
?dateSeq
detach("package:CBJTSA", unload = TRUE)
remove.packages("CBJTSA")
#Para instalar la librería a partir del archivo
install.packages("CBJTSA_1.0.zip", repos = NULL, type = "source")
library(CBJTSA)
#Me invento los tiempos para mostrar como funciona dateSeq y hacer los plots bien
?dateSeq
?arimaSimComp
